# -*- coding: utf-8 -*-
"""tur_dash.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lQyE2ECBdKV4C4hBUlFUAW5uRxNoqxVH
"""

import plotly.express as px
import plotly.graph_objects as go
import pandas as pd
from sklearn.decomposition import PCA
import dash
import dash_core_components as dcc
import dash_html_components as html
from dash.dependencies import Input, Output

# Create a Dash app
app = dash.Dash(__name__)

# Perform dimensionality reduction using PCA
pca = PCA(n_components=3)
disease_embeddings_3d = pca.fit_transform(icd_embeddings)

# Create a DataFrame for disease embeddings plot
disease_data_df = pd.DataFrame(disease_embeddings_3d, columns=['PC1', 'PC2', 'PC3'])
disease_data_df['Type'] = 'Disease'
disease_data_df['Name'] = disease_names

# Initialize the Dash layout
app.layout = html.Div([
    dcc.Dropdown(
        id='character-dropdown',
        options=[
            {'label': character_name, 'value': idx} for idx, character_name in enumerate(df_dost["name"])
        ],
        value=0  # Default value
    ),
    dcc.Graph(id='scatter-plot')
])

# Define callback to update the scatter plot based on dropdown selection
@app.callback(
    Output('scatter-plot', 'figure'),
    [Input('character-dropdown', 'value')]
)
def update_scatter_plot(selected_character_index):
    char_embedding_2d = df_dost['numpy_array'][selected_character_index].reshape(1, -1)
    char_embedding_3d = pca.transform(char_embedding_2d)

    # Create a DataFrame for character embedding plot
    character_data_df = pd.DataFrame(char_embedding_3d, columns=['PC1', 'PC2', 'PC3'])
    character_data_df['Type'] = 'Character'
    character_data_df['Name'] = df_dost["name"][selected_character_index]

    # Concatenate the two DataFrames
    combined_data_df = pd.concat([disease_data_df, character_data_df], ignore_index=True)

    if description:
      # Project the description embedding onto the PCA space
      description_embedding_3d = pca.transform(description_embedding)

      # Create a DataFrame for description embedding plot
      description_data_df = pd.DataFrame(description_embedding_3d, columns=['PC1', 'PC2', 'PC3'])
      description_data_df['Type'] = 'Description'
      description_data_df['Name'] = 'Description'

      # Concatenate the description data with combined_data_df
      combined_data_df = pd.concat([combined_data_df, description_data_df], ignore_index=True)

    # Define hover data for the scatter plot
    hover_data = {
        'PC1': False,  # Hide PC1 value
        'PC2': False,  # Hide PC2 value
        'PC3': False,  # Hide PC3 value
        'Name': True,  # Show Name value
        'Type': True   # Show Type value
    }

    # Create an interactive 3D scatter plot
    fig = px.scatter_3d(combined_data_df, x='PC1', y='PC2', z='PC3', color='Type', symbol='Type', hover_data=hover_data)

    # Add a transparent sphere around the character embedding point
    sphere_radius_pixels = 20  # Adjust this value to control the sphere size
    sphere_trace = go.Scatter3d(
        x=[char_embedding_3d[0, 0]],
        y=[char_embedding_3d[0, 1]],
        z=[char_embedding_3d[0, 2]],
        mode='markers',
        marker=dict(size=sphere_radius_pixels, color='rgba(0, 128, 255, 0.7)', opacity=0.5),  # Adjust the color, opacity, and size here
        name='Character Sphere'
    )
    fig.add_trace(sphere_trace)

    return fig

# Run the app
if __name__ == '__main__':
    app.run_server(debug=True)